import { AlgPaperComponent } from '../paper/alg-paper-component.js';
import { executeDelayedTaskQueue } from '../util/misc.js';
import { EventManager } from '../types/event-manager.js';
import { fireEvent, waitUntilDocumentReady } from '../util/f-html.js';
import { List } from '../types/list.js';

// @copyright @polymer\iron-resizable-behavior\iron-resizable-behavior.js
// @copyright 2017-2018 ALG

// TODO: use eventManager for all.
/**
 * Mixin Behavior
 *
 * IronResizableBehavior is a behavior that can be used in elements to coordinate
 * the flow of resize events between "resizers" (elements that control the size or hidden
 * state of their children) and "resizables" (elements that need to be notified when they
 * are resized or un-hidden by their parents in order to take action on their new measurements).
 *
 * Elements that perform measurement should add the IronResizableBehavior behavior
 * to their element definition and listen for the iron-resize event on themselves.
 * This event will be fired when they become showing after having been hidden,
 * when they are resized explicitly by another resizable, or when the window has been resized.
 *
 * @param {*} base
 */
export const AlgIronResizableBehavior = (base) => class extends base {
  // constructor() {
  //   // @ts-ignore
  //   super();

  //   console.log('iron-resizable-behavior', this);
  // }

  connectedCallback() {
    super.connectedCallback();
    this.resizableImpl.connectedCallback();
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.resizableImpl.disconnectedCallback();
  }

  /** Path to class implementation */
  // @ts-ignore
  get resizableImpl() {
    // @ts-ignore
    return this._resizableImpl || (this._resizableImpl = new AlgIronResizableImpl(this));
  }

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   * @param {HTMLElement} parentResizable
   */
  assignParentResizable(parentResizable) {
    this.attributeManager.change('parentResizable', parentResizable);
  }

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize() {
    this.taskQueue.add(this.resizableImpl.notifyResize);
    executeDelayedTaskQueue(this.taskQueue);
  }

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify(element) { return true; }

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   * @param {HTMLElement} target
   */
  stopResizeNotificationsFor(target) {
    this.resizableImpl.stopResizeNotificationsFor(target);
  }
};

/**
 *
 */
class AlgIronResizableImpl {
  /**
   * @param {AlgPaperComponent} me
   */
  constructor(me) {
    this.me = me;

    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = new List();
    // this._boundNotifyResize = this.notifyResize.bind(this);

    this.me.attributeManager
      // The closest ancestor element that implements `IronResizableBehavior`.
      .define('parentResizable') // _parentResizable in original
      .on((parentResizable) => {
        if (parentResizable) {
          EventManager.window.unsubscribeMe(this.me);
        }
      });

    this.me.eventManager
      .on('resize', (event) => {
        console.log('resize', event, this.me);
      })
      .on('iron-request-resize-notifications', (event) => {
        const target = event.detail.node;
        if (target === this.me || event.cancelBubble) { return; }
        event.stopPropagation();

        target.assignParentResizable(this.me);
        this._interestedResizables.add(target, { unique: true });

        console.log('iron-request received: ', event, this.me);
      }, { link: true }) // important! to stop bubble and sequential exec after fireEvent
      .subscribe();
  }

  connectedCallback() {
    this._requestResizeNotifications();
  }

  disconnectedCallback() {
    const parentResizable = this.me.attributeManager.get('parentResizable');
    if (parentResizable.value) {
      parentResizable.value.stopResizeNotificationsFor(this.me);
      parentResizable.update(null);
    } else {
      EventManager.window.unsubscribeMe(this.me, 'resize');
    }
  }

  /**
   * Binded function
   */
  get notifyResize() {
    return this._notifyResize || (this._notifyResize = this.__notifyResize.bind(this));
  }

  _fireResize() {
    this.me.eventManager.fire('resize', { node: this.me });
    // done:
    //   this.fire('iron-resize', null, {
    //     node: this,
    //     bubbles: false
    //   });
  }

  _notifyDescendant(descendant) {
    if (!this.me.loaded) return; // In IE10, attached is fired on children first

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  }

  /**
   * Delayed to make only one call, when triggerd from several attributeManager entries
   */
  __notifyResize() {
    console.log('**notify resize', this);

    // if (!this.me.loaded) return;

    this._interestedResizables.forEach((resizable) => {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    });

    this._fireResize();
  }

  // @ts-ignore
  resizerShouldNotify(element) { return this.me.resizerShouldNotify(element); }

  /**
   *
   */
  _requestResizeNotifications() {
    // We must be in document 'complete' state to assure the event bubbles well
    waitUntilDocumentReady().then(() => {
      fireEvent(this.me, 'iron-request-resize-notifications', {
        bubbles: true,
        cancelable: true,
        composed: true,
        detail: {
          node: this.me
        }
      });

      if (!this.me.attributeManager.getValue('parentResizable')) {
        EventManager.window
          .on('resize', (event) => {
            console.log('window resize:', event, this.me);
            this.__notifyResize();
          }, { me: this.me })
          .subscribe();
      }
      // console.log('parentREsizable', this.me.attributeManager.getValue('parentResizable'));

    //     if (!this._parentResizable) {
    //       window.addEventListener('resize', this._boundNotifyResize);
    //       this.notifyResize();
    //     }
    //   }
    });

    // console.log('iron-resizable-impl readyState', document.readyState); // interactive at this point

    // We wait for the document to be done loading before firing the event.
  //   if (document.readyState === 'loading') {
  //     var _requestResizeNotifications = this._requestResizeNotifications.bind(this);
  //     document.addEventListener('readystatechange', function readystatechanged() {
  //       document.removeEventListener('readystatechange', readystatechanged);
  //       _requestResizeNotifications();
  //     });
  //   } else {
  //     this.fire('iron-request-resize-notifications', null, {
  //       node: this,
  //       bubbles: true,
  //       cancelable: true
  //     });
  }

  /**
   * @param {HTMLElement} target
   */
  stopResizeNotificationsFor(target) {
    if (this._interestedResizables.contains(target)) {
      this._interestedResizables.remove(target);
      target.eventManager.unsubscribeMe(this.me, 'resize');
    }

    // done:
    //   var index = this._interestedResizables.indexOf(target);

    //   if (index > -1) {
    //     this._interestedResizables.splice(index, 1);
    //     this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
    //   }
  }
}

// properties: {
//

//   /**
//    * True if this element is currently notifying its descendant elements of
//    * resize.
//    */
//   _notifyingDescendant: {
//     type: Boolean,
//       value: false
//   }
// },

// listeners: {
//   'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
// },

// _onDescendantIronResize: function(event) {
//   if (this._notifyingDescendant) {
//     event.stopPropagation();
//     return;
//   }

//   // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
//   // otherwise non-bubbling event "just work." We do it manually here for
//   // the case where Polymer is not using shadow roots for whatever reason:
//   if (!Settings.useShadow) {
//     this._fireResize();
//   }
// },

// _onIronRequestResizeNotifications: function(event) {
//   var target = /** @type {!EventTarget} */ (dom(event).rootTarget);
//   if (target === this) {
//     return;
//   }

//   if (this._interestedResizables.indexOf(target) === -1) {
//     this._interestedResizables.push(target);
//     this.listen(target, 'iron-resize', '_onDescendantIronResize');
//   }

//   target.assignParentResizable(this);
//   this._notifyDescendant(target);

//   event.stopPropagation();
// },
